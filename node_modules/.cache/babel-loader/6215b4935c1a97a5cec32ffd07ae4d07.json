{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { getTabIndex } from '@progress/kendo-react-common';\nimport { UploadFileStatus } from './interfaces/UploadFileStatus';\nimport { UploadNavigation } from './UploadNavigation';\nimport axios from 'axios';\nimport utils from './utils/utils';\nimport stateUtils from './utils/stateUtils';\nimport connectionUtils from './utils/connectionUtils';\nimport validationUtils from './utils/validationUtils';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { packageMetadata } from './package-metadata';\n\nvar Upload =\n/** @class */\nfunction (_super) {\n  __extends(Upload, _super);\n\n  function Upload(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._httpSubscriptions = {};\n    /**\n     * @hidden\n     */\n\n    _this.focus = function () {\n      if (_this._uploadNavigation) {\n        _this._uploadNavigation.focus();\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.uploadFiles = function (filesForUpload) {\n      var async = _this.async;\n      stateUtils.setFilesStatus(filesForUpload, UploadFileStatus.Uploading);\n      stateUtils.groupForEach(filesForUpload, function (currentFiles, uid) {\n        var headers = connectionUtils.cloneRequestHeaders(async.saveHeaders || {});\n        var additionalData = {};\n        var eventData = {\n          target: _this,\n          files: currentFiles,\n          headers: headers,\n          additionalData: additionalData\n        };\n\n        if (_this.props.onBeforeUpload) {\n          _this.props.onBeforeUpload.call(undefined, eventData);\n        }\n\n        var requestOptions = connectionUtils.populateRequestOptions(eventData.headers, _this.async);\n        var formData = connectionUtils.populateUploadFormData(currentFiles, async.saveField, eventData.additionalData);\n\n        if (_this.isCustomSave) {\n          _this.props.saveUrl(currentFiles, {\n            formData: formData,\n            requestOptions: requestOptions\n          }, _this.onUploadProgress).then(function (event) {\n            return _this.onUploadSuccess(event.uid);\n          }).catch(function (event) {\n            return _this.onUploadError(event.uid);\n          });\n        } else {\n          var cancelTokenSource = axios.CancelToken.source();\n          _this._httpSubscriptions[uid] = cancelTokenSource;\n          axios(__assign({\n            method: async.saveMethod,\n            url: async.saveUrl,\n            data: formData,\n            cancelToken: cancelTokenSource.token\n          }, requestOptions, {\n            onUploadProgress: function (event) {\n              return _this.onUploadProgress(uid, event);\n            }\n          })).then(function (event) {\n            return _this.onUploadSuccess(uid, event);\n          }).catch(function (event) {\n            return _this.onUploadError(uid, event);\n          });\n        }\n      });\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.removeFiles = function (filesForRemove) {\n      var async = _this.async;\n      stateUtils.groupForEach(filesForRemove, function (currentFiles, uid) {\n        var headers = connectionUtils.cloneRequestHeaders(async.removeHeaders || {});\n        var additionalData = {};\n        var eventData = {\n          target: _this,\n          files: currentFiles,\n          headers: headers,\n          additionalData: additionalData\n        };\n\n        if (_this.props.onBeforeRemove) {\n          _this.props.onBeforeRemove.call(undefined, eventData);\n        }\n\n        var fileNames = currentFiles.map(function (file) {\n          return file.name;\n        });\n        var requestOptions = connectionUtils.populateRequestOptions(eventData.headers, _this.async);\n        var formData = connectionUtils.populateRemoveFormData(fileNames, async.removeField, eventData.additionalData);\n\n        if (_this.isCustomRemove) {\n          _this.props.removeUrl(currentFiles, {\n            formData: formData,\n            requestOptions: requestOptions\n          }).then(function (event) {\n            return _this.onRemoveSuccess(event.uid);\n          }).catch(function (event) {\n            return _this.onRemoveError(event.uid);\n          });\n        } else {\n          axios(__assign({\n            method: async.removeMethod,\n            url: async.removeUrl,\n            data: formData\n          }, requestOptions)).then(function (event) {\n            return _this.onRemoveSuccess(uid, event);\n          }).catch(function (event) {\n            return _this.onRemoveError(uid, event);\n          });\n        }\n      });\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onUpload = function () {\n      var newState = _this.fileStateCopy;\n      var groupedFiles = stateUtils.groupFilesByUid(newState);\n      var filesForUpload = stateUtils.filesForUpload(groupedFiles);\n\n      _this.uploadFiles(filesForUpload);\n\n      var onStatusChangeEvent = function () {\n        if (_this.props.onStatusChange) {\n          var eventData = {\n            target: _this,\n            newState: newState,\n            affectedFiles: stateUtils.flatFileGroup(filesForUpload)\n          };\n\n          _this.props.onStatusChange.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onStatusChangeEvent();\n      } else {\n        _this.setState({\n          files: newState\n        }, onStatusChangeEvent);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onAdd = function (files) {\n      // The problem when removing rawFile is that there is no reliable way of preserving it internally.\n      // For example, uid + filename - the filename can be changed at any moment.\n      var selectedFiles = utils.getAllFileInfo(files);\n      var newState;\n      selectedFiles = utils.assignGuidToFiles(selectedFiles, _this.async.batch);\n      validationUtils.validateFiles(selectedFiles, _this.props.restrictions);\n\n      if (!_this.props.multiple) {\n        newState = [];\n      } else {\n        newState = _this.fileStateCopy;\n      }\n\n      stateUtils.addMany(selectedFiles, newState);\n\n      if (_this.async.autoUpload) {\n        var groupedFiles = stateUtils.groupFilesByUid(newState);\n\n        _this.uploadFiles(stateUtils.filesForUpload(groupedFiles));\n      }\n\n      var onAddEvent = function () {\n        if (_this.props.onAdd) {\n          var eventData = {\n            target: _this,\n            newState: newState,\n            affectedFiles: selectedFiles\n          };\n\n          _this.props.onAdd.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onAddEvent();\n      } else {\n        _this.setState({\n          files: newState\n        }, onAddEvent);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onUploadProgress = function (uid, event) {\n      var percentComplete = Math.round(100 * event.loaded / event.total) || 0;\n      var newState = _this.fileStateCopy;\n      var filesWithProgress = newState.filter(function (file) {\n        return file.uid === uid;\n      });\n\n      if (!filesWithProgress.length) {\n        return;\n      }\n\n      filesWithProgress.forEach(function (file) {\n        file.progress = percentComplete;\n      });\n\n      var onProgressEvent = function () {\n        if (_this.props.onProgress) {\n          var eventData = {\n            target: _this,\n            newState: newState,\n            affectedFiles: filesWithProgress\n          };\n\n          _this.props.onProgress.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onProgressEvent();\n      } else {\n        _this.setState({\n          files: newState\n        }, onProgressEvent);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onUploadSuccess = function (uid, event) {\n      var newState = _this.fileStateCopy;\n      var successFiles = newState.filter(function (file) {\n        return file.uid === uid;\n      });\n      successFiles.forEach(function (file) {\n        file.status = UploadFileStatus.Uploaded;\n      });\n      delete _this._httpSubscriptions[uid];\n\n      var onStatusChangeEvent = function () {\n        if (_this.props.onStatusChange) {\n          var eventData = {\n            target: _this,\n            newState: newState,\n            affectedFiles: successFiles,\n            response: event ? connectionUtils.convertAxiosResponse(event) : undefined\n          };\n\n          _this.props.onStatusChange.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onStatusChangeEvent();\n      } else {\n        _this.setState({\n          files: newState\n        }, onStatusChangeEvent);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onUploadError = function (uid, event) {\n      var newState = _this.fileStateCopy;\n      var failedFiles = newState.filter(function (file) {\n        return file.uid === uid;\n      });\n      failedFiles.forEach(function (file) {\n        file.status = UploadFileStatus.UploadFailed;\n      });\n      delete _this._httpSubscriptions[uid];\n\n      if (!failedFiles.length) {\n        return;\n      }\n\n      var onStatusChangeEvent = function () {\n        if (_this.props.onStatusChange) {\n          var eventData = {\n            target: _this,\n            newState: newState,\n            affectedFiles: failedFiles,\n            response: event ? connectionUtils.convertAxiosResponse(event) : undefined\n          };\n\n          _this.props.onStatusChange.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onStatusChangeEvent();\n      } else {\n        _this.setState({\n          files: newState\n        }, onStatusChangeEvent);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onRemove = function (uid) {\n      var _a;\n\n      var newState = _this.fileStateCopy;\n      var filesForRemove = newState.filter(function (file) {\n        return file.uid === uid;\n      });\n      var filesToKeep = newState.filter(function (file) {\n        return file.uid !== uid;\n      });\n      var remoteRemoveStatuses = [UploadFileStatus.Uploaded, UploadFileStatus.Initial, UploadFileStatus.RemoveFailed];\n\n      if (remoteRemoveStatuses.indexOf(filesForRemove[0].status) > -1) {\n        var fileGroup = (_a = {}, _a[uid] = filesForRemove, _a);\n        stateUtils.setFilesStatus(fileGroup, UploadFileStatus.Removing);\n\n        _this.removeFiles(fileGroup);\n\n        var onStatusChangeEvent = function () {\n          if (_this.props.onStatusChange) {\n            var eventData = {\n              target: _this,\n              newState: newState,\n              affectedFiles: filesForRemove\n            };\n\n            _this.props.onStatusChange.call(undefined, eventData);\n          }\n        };\n\n        if (_this.isControlled) {\n          onStatusChangeEvent();\n        } else {\n          _this.setState({\n            files: newState\n          }, onStatusChangeEvent);\n        }\n      } else {\n        var onRemoveEvent = function () {\n          if (_this.props.onRemove) {\n            var eventData = {\n              target: _this,\n              newState: filesToKeep,\n              affectedFiles: filesForRemove\n            };\n\n            _this.props.onRemove.call(undefined, eventData);\n          }\n        };\n\n        if (_this.isControlled) {\n          onRemoveEvent();\n        } else {\n          _this.setState({\n            files: filesToKeep\n          }, onRemoveEvent);\n        }\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onRemoveSuccess = function (uid, event) {\n      var newState = _this.fileStateCopy;\n      var filesForRemove = newState.filter(function (file) {\n        return file.uid === uid;\n      });\n      var filesToKeep = newState.filter(function (file) {\n        return file.uid !== uid;\n      });\n\n      var onRemoveEvent = function () {\n        if (_this.props.onRemove) {\n          var eventData = {\n            target: _this,\n            newState: filesToKeep,\n            affectedFiles: filesForRemove,\n            response: event ? connectionUtils.convertAxiosResponse(event) : undefined\n          };\n\n          _this.props.onRemove.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onRemoveEvent();\n      } else {\n        _this.setState({\n          files: filesToKeep\n        }, onRemoveEvent);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onRemoveError = function (uid, event) {\n      var newState = _this.fileStateCopy;\n      var failedFiles = newState.filter(function (file) {\n        return file.uid === uid;\n      });\n      failedFiles.forEach(function (file) {\n        file.status = UploadFileStatus.RemoveFailed;\n      });\n\n      var onStatusChangeEvent = function () {\n        if (_this.props.onStatusChange) {\n          var eventData = {\n            target: _this,\n            newState: newState,\n            affectedFiles: failedFiles,\n            response: event ? connectionUtils.convertAxiosResponse(event) : undefined\n          };\n\n          _this.props.onStatusChange.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onStatusChangeEvent();\n      } else {\n        _this.setState({\n          files: newState\n        }, onStatusChangeEvent);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onRetry = function (uid) {\n      var newState = _this.fileStateCopy;\n      var filesForRetry = stateUtils.groupFilesByUid(newState.filter(function (file) {\n        return file.uid === uid;\n      }));\n      stateUtils.setFilesStatus(filesForRetry, UploadFileStatus.Uploading);\n\n      _this.uploadFiles(filesForRetry);\n\n      var onStatusChangeEvent = function () {\n        if (_this.props.onStatusChange) {\n          var eventData = {\n            target: _this,\n            newState: newState,\n            affectedFiles: stateUtils.flatFileGroup(filesForRetry)\n          };\n\n          _this.props.onStatusChange.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onStatusChangeEvent();\n      } else {\n        _this.setState({\n          files: newState\n        }, onStatusChangeEvent);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onCancel = function (uid) {\n      var newState = _this.fileStateCopy;\n      var filesToKeep = newState.filter(function (file) {\n        return file.uid !== uid;\n      });\n      var filesForRemove = newState.filter(function (file) {\n        return file.uid === uid;\n      });\n\n      if (_this._httpSubscriptions[uid]) {\n        _this._httpSubscriptions[uid].cancel();\n\n        delete _this._httpSubscriptions[uid];\n      }\n\n      if (_this.props.onCancel) {\n        var eventData = {\n          target: _this,\n          uid: uid\n        };\n\n        _this.props.onCancel.call(undefined, eventData);\n      }\n\n      var onRemoveEvent = function () {\n        if (_this.props.onRemove) {\n          var eventData = {\n            target: _this,\n            newState: filesToKeep,\n            affectedFiles: filesForRemove\n          };\n\n          _this.props.onRemove.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onRemoveEvent();\n      } else {\n        _this.setState({\n          files: filesToKeep\n        }, onRemoveEvent);\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onClear = function () {\n      if (!_this.files.length) {\n        return;\n      }\n\n      Object.keys(_this._httpSubscriptions).forEach(function (key) {\n        _this._httpSubscriptions[key].cancel();\n      });\n      _this._httpSubscriptions = {};\n\n      var onRemoveEvent = function () {\n        if (_this.props.onRemove) {\n          var eventData = {\n            target: _this,\n            newState: [],\n            affectedFiles: _this.fileStateCopy\n          };\n\n          _this.props.onRemove.call(undefined, eventData);\n        }\n      };\n\n      if (_this.isControlled) {\n        onRemoveEvent();\n      } else {\n        _this.setState({\n          files: []\n        }, onRemoveEvent);\n      }\n    };\n\n    validatePackage(packageMetadata);\n    _this.state = {\n      files: props.defaultFiles || []\n    };\n    return _this;\n  }\n\n  Object.defineProperty(Upload.prototype, \"async\", {\n    get: function () {\n      var _a = this.props,\n          autoUpload = _a.autoUpload,\n          batch = _a.batch,\n          removeField = _a.removeField,\n          removeHeaders = _a.removeHeaders,\n          removeMethod = _a.removeMethod,\n          removeUrl = _a.removeUrl,\n          responseType = _a.responseType,\n          saveField = _a.saveField,\n          saveHeaders = _a.saveHeaders,\n          saveMethod = _a.saveMethod,\n          saveUrl = _a.saveUrl,\n          withCredentials = _a.withCredentials;\n      return {\n        autoUpload: autoUpload,\n        batch: batch,\n        removeField: removeField,\n        removeHeaders: removeHeaders,\n        removeMethod: removeMethod,\n        removeUrl: removeUrl,\n        responseType: responseType,\n        saveField: saveField,\n        saveHeaders: saveHeaders,\n        saveMethod: saveMethod,\n        saveUrl: saveUrl,\n        withCredentials: withCredentials\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Upload.prototype, \"files\", {\n    get: function () {\n      var files = this.isControlled ? this.props.files : this.state.files;\n      return files || [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Upload.prototype, \"isControlled\", {\n    get: function () {\n      return !this.props.defaultFiles;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Upload.prototype, \"isCustomSave\", {\n    get: function () {\n      return this.props.saveUrl && typeof this.props.saveUrl === 'function';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Upload.prototype, \"isCustomRemove\", {\n    get: function () {\n      return this.props.removeUrl && typeof this.props.removeUrl === 'function';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Upload.prototype, \"fileStateCopy\", {\n    get: function () {\n      if (this.isControlled) {\n        return stateUtils.copyState(this.props.files);\n      } else {\n        return stateUtils.copyState(this.state.files);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Upload.prototype, \"actionElement\", {\n    /**\n     * @hidden\n     */\n    get: function () {\n      if (this._uploadNavigation) {\n        return this._uploadNavigation.actionElement;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n\n  Upload.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        showFileList = _a.showFileList,\n        onAdd = _a.onAdd,\n        onRemove = _a.onRemove,\n        onCancel = _a.onCancel,\n        autoUpload = _a.autoUpload,\n        showActionButtons = _a.showActionButtons,\n        actionsLayout = _a.actionsLayout,\n        tabIndex = _a.tabIndex,\n        disabled = _a.disabled,\n        others = __rest(_a, [\"showFileList\", \"onAdd\", \"onRemove\", \"onCancel\", \"autoUpload\", \"showActionButtons\", \"actionsLayout\", \"tabIndex\", \"disabled\"]);\n\n    var groupedFiles = stateUtils.groupFilesByUid(this.files);\n    var filesForUpload = stateUtils.filesForUpload(groupedFiles);\n    return React.createElement(UploadNavigation, __assign({\n      groupedFiles: groupedFiles,\n      className: this.props.className,\n      showFileList: showFileList && !!Object.keys(groupedFiles).length,\n      showActionButtons: showActionButtons && !autoUpload && !!Object.keys(filesForUpload).length,\n      actionsLayout: actionsLayout,\n      autoUpload: autoUpload,\n      disabled: disabled,\n      onAdd: this.onAdd,\n      onRemove: this.onRemove,\n      onClear: this.onClear,\n      onUpload: this.onUpload,\n      onRetry: this.onRetry,\n      onCancel: this.onCancel,\n      tabIndex: getTabIndex(tabIndex, disabled),\n      ref: function (ref) {\n        return _this._uploadNavigation = ref;\n      }\n    }, others));\n  };\n  /**\n   * @hidden\n   */\n\n\n  Upload.defaultProps = {\n    autoUpload: true,\n    batch: false,\n    removeField: 'fileNames',\n    removeHeaders: {},\n    removeMethod: 'POST',\n    removeUrl: '',\n    responseType: 'json',\n    saveField: 'files',\n    saveHeaders: {},\n    saveMethod: 'POST',\n    saveUrl: '',\n    withCredentials: true,\n    restrictions: {\n      allowedExtensions: [],\n      maxFileSize: 0,\n      minFileSize: 0\n    },\n    multiple: true,\n    showFileList: true,\n    showActionButtons: true,\n    actionsLayout: 'end',\n    disabled: false\n  };\n  /**\n   * @hidden\n   */\n\n  Upload.propTypes = {\n    autoUpload: PropTypes.bool,\n    batch: PropTypes.bool,\n    withCredentials: PropTypes.bool,\n    saveField: PropTypes.string,\n    saveHeaders: PropTypes.object,\n    saveMethod: PropTypes.string,\n    saveUrl: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    responseType: PropTypes.oneOf(['arraybuffer', 'blob', 'json', 'text']),\n    removeField: PropTypes.string,\n    removeHeaders: PropTypes.object,\n    removeMethod: PropTypes.string,\n    removeUrl: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    multiple: PropTypes.bool,\n    disabled: PropTypes.bool,\n    showFileList: PropTypes.bool,\n    showActionButtons: PropTypes.bool,\n    actionsLayout: PropTypes.oneOf(['start', 'center', 'end', 'stretched']),\n    tabIndex: PropTypes.number,\n    accept: PropTypes.string,\n    listItemUI: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.shape({\n      render: PropTypes.func.isRequired\n    })]),\n    restrictions: PropTypes.shape({\n      allowedExtensions: PropTypes.arrayOf(PropTypes.string),\n      maxFileSize: PropTypes.number,\n      minFileSize: PropTypes.number\n    }),\n    files: PropTypes.arrayOf(PropTypes.shape({\n      uid: PropTypes.string,\n      name: PropTypes.string,\n      extension: PropTypes.string,\n      size: PropTypes.number,\n      validationErrors: PropTypes.arrayOf(PropTypes.string),\n      status: PropTypes.oneOf([UploadFileStatus.Initial, UploadFileStatus.RemoveFailed, UploadFileStatus.Removing, UploadFileStatus.Selected, UploadFileStatus.UploadFailed, UploadFileStatus.Uploaded, UploadFileStatus.Uploading]),\n      progress: PropTypes.number,\n      getRawFile: PropTypes.func\n    })),\n    defaultFiles: PropTypes.arrayOf(PropTypes.shape({\n      uid: PropTypes.string,\n      name: PropTypes.string,\n      extension: PropTypes.string,\n      size: PropTypes.number,\n      validationErrors: PropTypes.arrayOf(PropTypes.string),\n      status: PropTypes.oneOf([UploadFileStatus.Initial, UploadFileStatus.RemoveFailed, UploadFileStatus.Removing, UploadFileStatus.Selected, UploadFileStatus.UploadFailed, UploadFileStatus.Uploaded, UploadFileStatus.Uploading]),\n      progress: PropTypes.number,\n      getRawFile: PropTypes.func\n    }))\n  };\n  return Upload;\n}(React.Component);\n\nexport { Upload };","map":null,"metadata":{},"sourceType":"module"}