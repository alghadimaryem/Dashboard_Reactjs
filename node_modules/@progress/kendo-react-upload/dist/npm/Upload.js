"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var PropTypes = require("prop-types");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var UploadFileStatus_1 = require("./interfaces/UploadFileStatus");
var UploadNavigation_1 = require("./UploadNavigation");
var axios_1 = require("axios");
var utils_1 = require("./utils/utils");
var stateUtils_1 = require("./utils/stateUtils");
var connectionUtils_1 = require("./utils/connectionUtils");
var validationUtils_1 = require("./utils/validationUtils");
var kendo_licensing_1 = require("@progress/kendo-licensing");
var package_metadata_1 = require("./package-metadata");
var Upload = /** @class */ (function (_super) {
    __extends(Upload, _super);
    function Upload(props) {
        var _this = _super.call(this, props) || this;
        _this._httpSubscriptions = {};
        /**
         * @hidden
         */
        _this.focus = function () {
            if (_this._uploadNavigation) {
                _this._uploadNavigation.focus();
            }
        };
        /**
         * @hidden
         */
        _this.uploadFiles = function (filesForUpload) {
            var async = _this.async;
            stateUtils_1.default.setFilesStatus(filesForUpload, UploadFileStatus_1.UploadFileStatus.Uploading);
            stateUtils_1.default.groupForEach(filesForUpload, function (currentFiles, uid) {
                var headers = connectionUtils_1.default.cloneRequestHeaders(async.saveHeaders || {});
                var additionalData = {};
                var eventData = {
                    target: _this,
                    files: currentFiles,
                    headers: headers,
                    additionalData: additionalData
                };
                if (_this.props.onBeforeUpload) {
                    _this.props.onBeforeUpload.call(undefined, eventData);
                }
                var requestOptions = connectionUtils_1.default.populateRequestOptions(eventData.headers, _this.async);
                var formData = connectionUtils_1.default.populateUploadFormData(currentFiles, async.saveField, eventData.additionalData);
                if (_this.isCustomSave) {
                    _this.props.saveUrl(currentFiles, { formData: formData, requestOptions: requestOptions }, _this.onUploadProgress)
                        .then(function (event) { return _this.onUploadSuccess(event.uid); })
                        .catch(function (event) { return _this.onUploadError(event.uid); });
                }
                else {
                    var cancelTokenSource = axios_1.default.CancelToken.source();
                    _this._httpSubscriptions[uid] = cancelTokenSource;
                    axios_1.default(__assign({ method: async.saveMethod, url: async.saveUrl, data: formData, cancelToken: cancelTokenSource.token }, requestOptions, { onUploadProgress: function (event) { return _this.onUploadProgress(uid, event); } }))
                        .then(function (event) { return _this.onUploadSuccess(uid, event); })
                        .catch(function (event) { return _this.onUploadError(uid, event); });
                }
            });
        };
        /**
         * @hidden
         */
        _this.removeFiles = function (filesForRemove) {
            var async = _this.async;
            stateUtils_1.default.groupForEach(filesForRemove, function (currentFiles, uid) {
                var headers = connectionUtils_1.default.cloneRequestHeaders(async.removeHeaders || {});
                var additionalData = {};
                var eventData = {
                    target: _this,
                    files: currentFiles,
                    headers: headers,
                    additionalData: additionalData
                };
                if (_this.props.onBeforeRemove) {
                    _this.props.onBeforeRemove.call(undefined, eventData);
                }
                var fileNames = currentFiles.map(function (file) { return file.name; });
                var requestOptions = connectionUtils_1.default.populateRequestOptions(eventData.headers, _this.async);
                var formData = connectionUtils_1.default.populateRemoveFormData(fileNames, async.removeField, eventData.additionalData);
                if (_this.isCustomRemove) {
                    _this.props.removeUrl(currentFiles, { formData: formData, requestOptions: requestOptions })
                        .then(function (event) { return _this.onRemoveSuccess(event.uid); })
                        .catch(function (event) { return _this.onRemoveError(event.uid); });
                }
                else {
                    axios_1.default(__assign({ method: async.removeMethod, url: async.removeUrl, data: formData }, requestOptions))
                        .then(function (event) { return _this.onRemoveSuccess(uid, event); })
                        .catch(function (event) { return _this.onRemoveError(uid, event); });
                }
            });
        };
        /**
         * @hidden
         */
        _this.onUpload = function () {
            var newState = _this.fileStateCopy;
            var groupedFiles = stateUtils_1.default.groupFilesByUid(newState);
            var filesForUpload = stateUtils_1.default.filesForUpload(groupedFiles);
            _this.uploadFiles(filesForUpload);
            var onStatusChangeEvent = function () {
                if (_this.props.onStatusChange) {
                    var eventData = {
                        target: _this,
                        newState: newState,
                        affectedFiles: stateUtils_1.default.flatFileGroup(filesForUpload)
                    };
                    _this.props.onStatusChange.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onStatusChangeEvent();
            }
            else {
                _this.setState({ files: newState }, onStatusChangeEvent);
            }
        };
        /**
         * @hidden
         */
        _this.onAdd = function (files) {
            // The problem when removing rawFile is that there is no reliable way of preserving it internally.
            // For example, uid + filename - the filename can be changed at any moment.
            var selectedFiles = utils_1.default.getAllFileInfo(files);
            var newState;
            selectedFiles = utils_1.default.assignGuidToFiles(selectedFiles, _this.async.batch);
            validationUtils_1.default.validateFiles(selectedFiles, _this.props.restrictions);
            if (!_this.props.multiple) {
                newState = [];
            }
            else {
                newState = _this.fileStateCopy;
            }
            stateUtils_1.default.addMany(selectedFiles, newState);
            if (_this.async.autoUpload) {
                var groupedFiles = stateUtils_1.default.groupFilesByUid(newState);
                _this.uploadFiles(stateUtils_1.default.filesForUpload(groupedFiles));
            }
            var onAddEvent = function () {
                if (_this.props.onAdd) {
                    var eventData = {
                        target: _this,
                        newState: newState,
                        affectedFiles: selectedFiles
                    };
                    _this.props.onAdd.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onAddEvent();
            }
            else {
                _this.setState({ files: newState }, onAddEvent);
            }
        };
        /**
         * @hidden
         */
        _this.onUploadProgress = function (uid, event) {
            var percentComplete = Math.round(100 * event.loaded / event.total) || 0;
            var newState = _this.fileStateCopy;
            var filesWithProgress = newState.filter(function (file) { return file.uid === uid; });
            if (!filesWithProgress.length) {
                return;
            }
            filesWithProgress.forEach(function (file) {
                file.progress = percentComplete;
            });
            var onProgressEvent = function () {
                if (_this.props.onProgress) {
                    var eventData = {
                        target: _this,
                        newState: newState,
                        affectedFiles: filesWithProgress
                    };
                    _this.props.onProgress.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onProgressEvent();
            }
            else {
                _this.setState({ files: newState }, onProgressEvent);
            }
        };
        /**
         * @hidden
         */
        _this.onUploadSuccess = function (uid, event) {
            var newState = _this.fileStateCopy;
            var successFiles = newState.filter(function (file) { return file.uid === uid; });
            successFiles.forEach(function (file) {
                file.status = UploadFileStatus_1.UploadFileStatus.Uploaded;
            });
            delete _this._httpSubscriptions[uid];
            var onStatusChangeEvent = function () {
                if (_this.props.onStatusChange) {
                    var eventData = {
                        target: _this,
                        newState: newState,
                        affectedFiles: successFiles,
                        response: event ? connectionUtils_1.default.convertAxiosResponse(event) : undefined
                    };
                    _this.props.onStatusChange.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onStatusChangeEvent();
            }
            else {
                _this.setState({ files: newState }, onStatusChangeEvent);
            }
        };
        /**
         * @hidden
         */
        _this.onUploadError = function (uid, event) {
            var newState = _this.fileStateCopy;
            var failedFiles = newState.filter(function (file) { return file.uid === uid; });
            failedFiles.forEach(function (file) {
                file.status = UploadFileStatus_1.UploadFileStatus.UploadFailed;
            });
            delete _this._httpSubscriptions[uid];
            if (!failedFiles.length) {
                return;
            }
            var onStatusChangeEvent = function () {
                if (_this.props.onStatusChange) {
                    var eventData = {
                        target: _this,
                        newState: newState,
                        affectedFiles: failedFiles,
                        response: event ? connectionUtils_1.default.convertAxiosResponse(event) : undefined
                    };
                    _this.props.onStatusChange.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onStatusChangeEvent();
            }
            else {
                _this.setState({ files: newState }, onStatusChangeEvent);
            }
        };
        /**
         * @hidden
         */
        _this.onRemove = function (uid) {
            var _a;
            var newState = _this.fileStateCopy;
            var filesForRemove = newState.filter(function (file) { return file.uid === uid; });
            var filesToKeep = newState.filter(function (file) { return file.uid !== uid; });
            var remoteRemoveStatuses = [
                UploadFileStatus_1.UploadFileStatus.Uploaded,
                UploadFileStatus_1.UploadFileStatus.Initial,
                UploadFileStatus_1.UploadFileStatus.RemoveFailed
            ];
            if (remoteRemoveStatuses.indexOf(filesForRemove[0].status) > -1) {
                var fileGroup = (_a = {},
                    _a[uid] = filesForRemove,
                    _a);
                stateUtils_1.default.setFilesStatus(fileGroup, UploadFileStatus_1.UploadFileStatus.Removing);
                _this.removeFiles(fileGroup);
                var onStatusChangeEvent = function () {
                    if (_this.props.onStatusChange) {
                        var eventData = {
                            target: _this,
                            newState: newState,
                            affectedFiles: filesForRemove
                        };
                        _this.props.onStatusChange.call(undefined, eventData);
                    }
                };
                if (_this.isControlled) {
                    onStatusChangeEvent();
                }
                else {
                    _this.setState({ files: newState }, onStatusChangeEvent);
                }
            }
            else {
                var onRemoveEvent = function () {
                    if (_this.props.onRemove) {
                        var eventData = {
                            target: _this,
                            newState: filesToKeep,
                            affectedFiles: filesForRemove
                        };
                        _this.props.onRemove.call(undefined, eventData);
                    }
                };
                if (_this.isControlled) {
                    onRemoveEvent();
                }
                else {
                    _this.setState({ files: filesToKeep }, onRemoveEvent);
                }
            }
        };
        /**
         * @hidden
         */
        _this.onRemoveSuccess = function (uid, event) {
            var newState = _this.fileStateCopy;
            var filesForRemove = newState.filter(function (file) { return file.uid === uid; });
            var filesToKeep = newState.filter(function (file) { return file.uid !== uid; });
            var onRemoveEvent = function () {
                if (_this.props.onRemove) {
                    var eventData = {
                        target: _this,
                        newState: filesToKeep,
                        affectedFiles: filesForRemove,
                        response: event ? connectionUtils_1.default.convertAxiosResponse(event) : undefined
                    };
                    _this.props.onRemove.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onRemoveEvent();
            }
            else {
                _this.setState({ files: filesToKeep }, onRemoveEvent);
            }
        };
        /**
         * @hidden
         */
        _this.onRemoveError = function (uid, event) {
            var newState = _this.fileStateCopy;
            var failedFiles = newState.filter(function (file) { return file.uid === uid; });
            failedFiles.forEach(function (file) {
                file.status = UploadFileStatus_1.UploadFileStatus.RemoveFailed;
            });
            var onStatusChangeEvent = function () {
                if (_this.props.onStatusChange) {
                    var eventData = {
                        target: _this,
                        newState: newState,
                        affectedFiles: failedFiles,
                        response: event ? connectionUtils_1.default.convertAxiosResponse(event) : undefined
                    };
                    _this.props.onStatusChange.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onStatusChangeEvent();
            }
            else {
                _this.setState({ files: newState }, onStatusChangeEvent);
            }
        };
        /**
         * @hidden
         */
        _this.onRetry = function (uid) {
            var newState = _this.fileStateCopy;
            var filesForRetry = stateUtils_1.default.groupFilesByUid(newState.filter(function (file) { return file.uid === uid; }));
            stateUtils_1.default.setFilesStatus(filesForRetry, UploadFileStatus_1.UploadFileStatus.Uploading);
            _this.uploadFiles(filesForRetry);
            var onStatusChangeEvent = function () {
                if (_this.props.onStatusChange) {
                    var eventData = {
                        target: _this,
                        newState: newState,
                        affectedFiles: stateUtils_1.default.flatFileGroup(filesForRetry)
                    };
                    _this.props.onStatusChange.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onStatusChangeEvent();
            }
            else {
                _this.setState({ files: newState }, onStatusChangeEvent);
            }
        };
        /**
         * @hidden
         */
        _this.onCancel = function (uid) {
            var newState = _this.fileStateCopy;
            var filesToKeep = newState.filter(function (file) { return file.uid !== uid; });
            var filesForRemove = newState.filter(function (file) { return file.uid === uid; });
            if (_this._httpSubscriptions[uid]) {
                _this._httpSubscriptions[uid].cancel();
                delete _this._httpSubscriptions[uid];
            }
            if (_this.props.onCancel) {
                var eventData = {
                    target: _this,
                    uid: uid
                };
                _this.props.onCancel.call(undefined, eventData);
            }
            var onRemoveEvent = function () {
                if (_this.props.onRemove) {
                    var eventData = {
                        target: _this,
                        newState: filesToKeep,
                        affectedFiles: filesForRemove
                    };
                    _this.props.onRemove.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onRemoveEvent();
            }
            else {
                _this.setState({ files: filesToKeep }, onRemoveEvent);
            }
        };
        /**
         * @hidden
         */
        _this.onClear = function () {
            if (!_this.files.length) {
                return;
            }
            Object.keys(_this._httpSubscriptions).forEach(function (key) {
                _this._httpSubscriptions[key].cancel();
            });
            _this._httpSubscriptions = {};
            var onRemoveEvent = function () {
                if (_this.props.onRemove) {
                    var eventData = {
                        target: _this,
                        newState: [],
                        affectedFiles: _this.fileStateCopy
                    };
                    _this.props.onRemove.call(undefined, eventData);
                }
            };
            if (_this.isControlled) {
                onRemoveEvent();
            }
            else {
                _this.setState({ files: [] }, onRemoveEvent);
            }
        };
        kendo_licensing_1.validatePackage(package_metadata_1.packageMetadata);
        _this.state = {
            files: props.defaultFiles || []
        };
        return _this;
    }
    Object.defineProperty(Upload.prototype, "async", {
        get: function () {
            var _a = this.props, autoUpload = _a.autoUpload, batch = _a.batch, removeField = _a.removeField, removeHeaders = _a.removeHeaders, removeMethod = _a.removeMethod, removeUrl = _a.removeUrl, responseType = _a.responseType, saveField = _a.saveField, saveHeaders = _a.saveHeaders, saveMethod = _a.saveMethod, saveUrl = _a.saveUrl, withCredentials = _a.withCredentials;
            return {
                autoUpload: autoUpload,
                batch: batch,
                removeField: removeField,
                removeHeaders: removeHeaders,
                removeMethod: removeMethod,
                removeUrl: removeUrl,
                responseType: responseType,
                saveField: saveField,
                saveHeaders: saveHeaders,
                saveMethod: saveMethod,
                saveUrl: saveUrl,
                withCredentials: withCredentials
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Upload.prototype, "files", {
        get: function () {
            var files = this.isControlled ? this.props.files : this.state.files;
            return files || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Upload.prototype, "isControlled", {
        get: function () {
            return !this.props.defaultFiles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Upload.prototype, "isCustomSave", {
        get: function () {
            return this.props.saveUrl && typeof this.props.saveUrl === 'function';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Upload.prototype, "isCustomRemove", {
        get: function () {
            return this.props.removeUrl && typeof this.props.removeUrl === 'function';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Upload.prototype, "fileStateCopy", {
        get: function () {
            if (this.isControlled) {
                return stateUtils_1.default.copyState(this.props.files);
            }
            else {
                return stateUtils_1.default.copyState(this.state.files);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Upload.prototype, "actionElement", {
        /**
         * @hidden
         */
        get: function () {
            if (this._uploadNavigation) {
                return this._uploadNavigation.actionElement;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    Upload.prototype.render = function () {
        var _this = this;
        var _a = this.props, showFileList = _a.showFileList, onAdd = _a.onAdd, onRemove = _a.onRemove, onCancel = _a.onCancel, autoUpload = _a.autoUpload, showActionButtons = _a.showActionButtons, actionsLayout = _a.actionsLayout, tabIndex = _a.tabIndex, disabled = _a.disabled, others = __rest(_a, ["showFileList", "onAdd", "onRemove", "onCancel", "autoUpload", "showActionButtons", "actionsLayout", "tabIndex", "disabled"]);
        var groupedFiles = stateUtils_1.default.groupFilesByUid(this.files);
        var filesForUpload = stateUtils_1.default.filesForUpload(groupedFiles);
        return (React.createElement(UploadNavigation_1.UploadNavigation, __assign({ groupedFiles: groupedFiles, className: this.props.className, showFileList: showFileList && !!Object.keys(groupedFiles).length, showActionButtons: showActionButtons && !autoUpload && !!Object.keys(filesForUpload).length, actionsLayout: actionsLayout, autoUpload: autoUpload, disabled: disabled, onAdd: this.onAdd, onRemove: this.onRemove, onClear: this.onClear, onUpload: this.onUpload, onRetry: this.onRetry, onCancel: this.onCancel, tabIndex: kendo_react_common_1.getTabIndex(tabIndex, disabled), ref: function (ref) { return _this._uploadNavigation = ref; } }, others)));
    };
    /**
     * @hidden
     */
    Upload.defaultProps = {
        autoUpload: true,
        batch: false,
        removeField: 'fileNames',
        removeHeaders: {},
        removeMethod: 'POST',
        removeUrl: '',
        responseType: 'json',
        saveField: 'files',
        saveHeaders: {},
        saveMethod: 'POST',
        saveUrl: '',
        withCredentials: true,
        restrictions: {
            allowedExtensions: [],
            maxFileSize: 0,
            minFileSize: 0
        },
        multiple: true,
        showFileList: true,
        showActionButtons: true,
        actionsLayout: 'end',
        disabled: false
    };
    /**
     * @hidden
     */
    Upload.propTypes = {
        autoUpload: PropTypes.bool,
        batch: PropTypes.bool,
        withCredentials: PropTypes.bool,
        saveField: PropTypes.string,
        saveHeaders: PropTypes.object,
        saveMethod: PropTypes.string,
        saveUrl: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
        responseType: PropTypes.oneOf(['arraybuffer', 'blob', 'json', 'text']),
        removeField: PropTypes.string,
        removeHeaders: PropTypes.object,
        removeMethod: PropTypes.string,
        removeUrl: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
        multiple: PropTypes.bool,
        disabled: PropTypes.bool,
        showFileList: PropTypes.bool,
        showActionButtons: PropTypes.bool,
        actionsLayout: PropTypes.oneOf(['start', 'center', 'end', 'stretched']),
        tabIndex: PropTypes.number,
        accept: PropTypes.string,
        listItemUI: PropTypes.oneOfType([
            PropTypes.func,
            PropTypes.string,
            PropTypes.shape({ render: PropTypes.func.isRequired })
        ]),
        restrictions: PropTypes.shape({
            allowedExtensions: PropTypes.arrayOf(PropTypes.string),
            maxFileSize: PropTypes.number,
            minFileSize: PropTypes.number
        }),
        files: PropTypes.arrayOf(PropTypes.shape({
            uid: PropTypes.string,
            name: PropTypes.string,
            extension: PropTypes.string,
            size: PropTypes.number,
            validationErrors: PropTypes.arrayOf(PropTypes.string),
            status: PropTypes.oneOf([
                UploadFileStatus_1.UploadFileStatus.Initial,
                UploadFileStatus_1.UploadFileStatus.RemoveFailed,
                UploadFileStatus_1.UploadFileStatus.Removing,
                UploadFileStatus_1.UploadFileStatus.Selected,
                UploadFileStatus_1.UploadFileStatus.UploadFailed,
                UploadFileStatus_1.UploadFileStatus.Uploaded,
                UploadFileStatus_1.UploadFileStatus.Uploading
            ]),
            progress: PropTypes.number,
            getRawFile: PropTypes.func
        })),
        defaultFiles: PropTypes.arrayOf(PropTypes.shape({
            uid: PropTypes.string,
            name: PropTypes.string,
            extension: PropTypes.string,
            size: PropTypes.number,
            validationErrors: PropTypes.arrayOf(PropTypes.string),
            status: PropTypes.oneOf([
                UploadFileStatus_1.UploadFileStatus.Initial,
                UploadFileStatus_1.UploadFileStatus.RemoveFailed,
                UploadFileStatus_1.UploadFileStatus.Removing,
                UploadFileStatus_1.UploadFileStatus.Selected,
                UploadFileStatus_1.UploadFileStatus.UploadFailed,
                UploadFileStatus_1.UploadFileStatus.Uploaded,
                UploadFileStatus_1.UploadFileStatus.Uploading
            ]),
            progress: PropTypes.number,
            getRawFile: PropTypes.func
        }))
    };
    return Upload;
}(React.Component));
exports.Upload = Upload;
//# sourceMappingURL=Upload.js.map